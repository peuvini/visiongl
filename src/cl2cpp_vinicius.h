
/*********************************************************************
***                                                                 ***
***  Source code generated by cl2cpp.pl                             ***
***                                                                 ***
***  Please do not edit                                             ***
***                                                                 ***
*********************************************************************/
#include "vglImage.h"

#include "vglShape.h"

#include "vglStrEl.h"

/** Arithmetic-mean filter.
 *
 *  Para cada pixel (x,y) calcula  
 *      f̂(x,y) = 1/(m·n) · Σ g(s,t) , (s,t) ∈ janela m×n
 *
 *  - `win`  = tamanho da janela (m = n = win) - deve ser ímpar  
 *  - Usa endereço `CLK_ADDRESS_CLAMP` → replica o valor da borda  
 *  - Processa imagens RGBA (UNORM_INT8 ou FLOAT); acumula em `float4`
 */
void vglClArithmeticMean(VglImage* img_input, VglImage* img_output, int win);

/** 
 * Filtro Bilateral: aplica ponderação espacial e de similaridade (range) para suavização preservando bordas.
 * A função lê a imagem de entrada e escreve a imagem filtrada na saída.
 * Os parâmetros sigma_spatial, sigma_range, window_size_x e window_size_y foram fixados.
 */
void vglClBilateral(VglImage* img_input, VglImage* img_output);

/** vglClGaussianNoise
 *
 *  Adiciona ruído gaussiano N(μ, σ²) pixel-a-pixel:
 *      out(x,y) = clamp( in(x,y) + μ + σ·Z , 0 , 1 )
 *  onde Z é obtido pelo método de Box–Muller a partir de dois
 *  números U ~ U(0,1) gerados por um LCG simples (Park-Miller).
 *
 *  Parâmetros
 *      img_input   – imagem de entrada  (UNORM_INT8 ou FLOAT [0-1])
 *      img_output  – imagem de saída    (mesmo formato)
 *      seed        – semente global (mude em cada execução se quiser
 *                    ruídos diferentes)
 *      mean        – μ   (ex.: 0.0f)
 *      sigma       – σ   (ex.: 0.1f → variância 0.01)
 *
 *  O kernel produz **um** número gaussiano por pixel e o aplica a
 *  todos os canais (RGBA).  Para canais independentes basta gerar
 *  quatro amostras em vez de uma.
 */
void vglClGaussianNoise(VglImage* img_input, VglImage* img_output, uint seed, float mean, float sigma);

/** Geometric mean of src image. Result is stored in dst image.
*/
void vglClGeometricMean(VglImage* img_input, VglImage* img_output);

/** Harmonic mean of src image. Result is stored in dst image.
 *
 *  f̂(x,y) = (m·n) / Σ [ 1 / g(s,t) ]
 *  where m = window_size_x, n = window_size_y
 */
void vglClHarmonicMean(VglImage* img_input, VglImage* img_output);

/** 
 * vglClLehmerRNG: Gera dois valores aleatórios diferentes (randValX, randValY)
 *                  usando duas sementes diferentes e escreve em .x e .y do pixel.
 *                  Assim, cada pixel terá (x=U1, y=U2, z=0, w=1).
 *                  
 * Parâmetros:
 *   out_img -> imagem de saída
 *   seed1, seed2 -> sementes para cada canal
 */
void vglClLehmerRNG(VglImage* out_img, int seed1, int seed2);

